<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0D0D0D">
    <title>10:13</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Karla:wght@700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/globe.gl@2.27.0/dist/globe.gl.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Karla', sans-serif;
            background-color: #0D0D0D;
            color: #FFFFFF;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        /* Login Screen */
        .login-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .logo {
            font-size: 48px;
            font-weight: 700;
            text-transform: lowercase;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00FFFF, #FF00FF, #FFFF00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .version {
            font-size: 14px;
            color: #666;
            margin-bottom: 40px;
            text-transform: lowercase;
        }

        .btn {
            background-color: #FFFFFF;
            color: #0D0D0D;
            border: none;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: 700;
            font-family: 'Karla', sans-serif;
            text-transform: lowercase;
            cursor: pointer;
            border-radius: 8px;
            width: 100%;
            max-width: 300px;
            transition: opacity 0.3s;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Chart Screen */
        .chart-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        .chart-screen.active {
            display: block;
        }

        .chart-wrapper {
            width: 100%;
            height: 100%;
            padding: 20px;
            position: relative;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 20px;
        }

        .title {
            font-size: 32px;
            font-weight: 700;
            text-transform: lowercase;
            cursor: pointer;
            background: linear-gradient(45deg, #00FFFF, #FF00FF, #FFFF00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .toggle {
            display: flex;
            align-items: center;
            background-color: #1A1A1A;
            border-radius: 20px;
            padding: 4px;
        }

        .toggle-btn {
            background-color: transparent;
            color: #FFFFFF;
            border: none;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Karla', sans-serif;
            text-transform: lowercase;
            cursor: pointer;
            border-radius: 16px;
            transition: all 0.3s;
        }

        .toggle-btn.active {
            background-color: #FFFFFF;
            color: #0D0D0D;
        }

        .chart-container {
            flex: 1;
            position: relative;
            padding: 0 20px 90px 20px;
            min-height: 0;
            height: calc(100% - 80px);
        }

        #myChart {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }

        #globeViz {
            width: 100%;
            height: 100%;
            display: none;
        }

        #globeViz.active {
            display: block;
        }

        .globe-legend {
            position: absolute;
            bottom: 30px;
            left: 40px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.7);
            padding: 12px 16px;
            border-radius: 8px;
            display: none;
        }

        .globe-legend.active {
            display: block;
        }

        .legend-title {
            font-weight: 700;
            margin-bottom: 8px;
            text-transform: lowercase;
        }

        .legend-gradient {
            width: 120px;
            height: 8px;
            background: linear-gradient(90deg, #00FFFF, #FF00FF, #FFFF00);
            border-radius: 4px;
            margin-bottom: 4px;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            opacity: 0.7;
        }

        .view-toggle-header {
            display: flex;
            align-items: center;
            background-color: #1A1A1A;
            border-radius: 20px;
            padding: 4px;
            gap: 4px;
        }

        .view-toggle-bottom {
            position: absolute;
            bottom: 50px;
            left: 20px;
            display: flex;
            align-items: center;
            background-color: #1A1A1A;
            border-radius: 20px;
            padding: 4px;
            gap: 4px;
        }

        .date-range {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            font-size: 12px;
            color: #666;
        }

        .view-btn {
            background-color: transparent;
            color: #FFFFFF;
            border: none;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Karla', sans-serif;
            text-transform: lowercase;
            cursor: pointer;
            border-radius: 16px;
            transition: all 0.3s;
        }

        .view-btn.active {
            background-color: #FFFFFF;
            color: #0D0D0D;
        }

        /* Quiz Screen */
        .quiz-screen {
            display: none;
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        .quiz-screen.active {
            display: block;
        }

        .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 6px;
            background: linear-gradient(90deg, #00FFFF, #FF00FF, #FFFF00);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        .card-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .card {
            width: 100%;
            max-width: 400px;
            height: 60%;
            border-radius: 16px;
            padding: 32px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            cursor: grab;
            user-select: none;
            transition: all 0.3s ease;
            border: 2px solid;
            background-color: #0D0D0D;
        }

        .card.dragging {
            cursor: grabbing;
            transition: none;
        }

        .section-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            text-transform: lowercase;
            font-weight: 700;
        }

        .icon {
            width: 20px;
            height: 20px;
        }

        .question-text {
            font-size: 48px;
            font-weight: 700;
            text-transform: lowercase;
            line-height: 1.2;
            text-align: center;
            word-break: break-word;
        }

        .rating-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            flex: 1;
            justify-content: center;
        }

        .rating-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 700;
            transition: all 0.2s;
            background-color: transparent;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
            flex: 1;
            justify-content: center;
        }

        .slider-value {
            font-size: 72px;
            font-weight: 700;
            margin-bottom: 16px;
        }

        .slider-wrapper {
            width: 100%;
            max-width: 350px;
        }

        .hour-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            background: #1A1A1A;
        }

        .hour-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
        }

        .hour-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }

        .slider-submit {
            background-color: transparent;
            border: 2px solid;
            padding: 12px 32px;
            border-radius: 8px;
            font-family: 'Karla', sans-serif;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            text-transform: lowercase;
            transition: all 0.2s;
        }

        .slider-submit:active {
            transform: scale(0.95);
        }

        .text-input-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            flex: 1;
            justify-content: center;
        }

        .text-input {
            width: 100%;
            min-height: 150px;
            background-color: transparent;
            border: 2px solid #FFFFFF;
            border-radius: 8px;
            padding: 16px;
            color: #FFFFFF;
            font-family: 'Karla', sans-serif;
            font-size: 16px;
            font-weight: 700;
            resize: none;
            outline: none;
        }

        .text-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .input-controls {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .mic-btn, .submit-btn {
            background-color: transparent;
            border: 2px solid #FFFFFF;
            color: #FFFFFF;
            padding: 12px 24px;
            border-radius: 8px;
            font-family: 'Karla', sans-serif;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .mic-btn:active, .submit-btn:active {
            background-color: #FFFFFF;
            color: #0D0D0D;
        }

        .mic-btn.recording {
            background-color: #FF0000;
            border-color: #FF0000;
            color: #FFFFFF;
        }

        /* Data Popup */
        .data-popup {
            position: fixed;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 90%;
            background-color: #0D0D0D;
            border: 2px solid #FFFFFF;
            border-radius: 16px;
            padding: 32px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .data-popup.active {
            display: block;
        }

        .popup-date {
            font-size: 12px;
            color: #666;
            margin-bottom: 20px;
            text-transform: lowercase;
        }

        .popup-section {
            margin-bottom: 24px;
        }

        .popup-section-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: lowercase;
        }

        .popup-item {
            margin-left: 28px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .popup-item.yes {
            opacity: 1;
        }

        .popup-item.no {
            opacity: 0.3;
        }

        .popup-response {
            background-color: #1A1A1A;
            border: 2px solid #FFFFFF;
            border-radius: 8px;
            padding: 16px;
            color: #FFFFFF;
            font-size: 14px;
            line-height: 1.6;
            margin-top: 8px;
            white-space: pre-wrap;
        }

        .popup-rating {
            font-size: 48px;
            font-weight: 700;
            color: #FFFFFF;
            text-align: center;
            margin: 16px 0;
        }

        .popup-hours {
            font-size: 32px;
            font-weight: 700;
            text-align: center;
            margin: 12px 0;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="login-screen">
        <div class="logo">10:13</div>
        <div class="version">v1.1.4</div>
        <button class="btn" onclick="handleLogin()">sign in with google</button>
    </div>

    <!-- Chart Screen -->
    <div id="chartScreen" class="chart-screen">
        <div class="chart-wrapper">
            <div class="header">
                <div class="title" onclick="startQuiz()">10:13</div>
                <div class="toggle">
                    <button class="toggle-btn active" id="toggle1w" onclick="setTimeRange('1w')">1w</button>
                    <button class="toggle-btn" id="toggle1m" onclick="setTimeRange('1m')">1m</button>
                    <button class="toggle-btn" id="toggleAll" onclick="setTimeRange('all')">all</button>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="myChart"></canvas>
                <div id="globeViz"></div>
                <div class="globe-legend" id="globeLegend">
                    <div class="legend-title">entries over time</div>
                    <div class="legend-gradient"></div>
                    <div class="legend-labels">
                        <span>oldest</span>
                        <span>newest</span>
                    </div>
                </div>
                <div class="view-toggle-bottom" id="viewToggle">
                    <button class="view-btn active" id="viewPercent" onclick="setChartMode('percent')">%</button>
                    <button class="view-btn" id="viewHours" onclick="setChartMode('hours')">hours</button>
                    <button class="view-btn" id="viewLoc" onclick="setChartMode('loc')">loc</button>
                </div>
                <div class="date-range" id="dateRange">
                    <span id="dateStart"></span>
                    <span id="dateEnd"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Data Popup -->
    <div id="dataPopup" class="data-popup">
        <div id="popupContent"></div>
    </div>

    <!-- Quiz Screen -->
    <div id="quizScreen" class="quiz-screen">
        <div class="progress-bar" id="progressBar"></div>
        <div class="card-container">
            <div class="card" id="card">
                <div class="section-label" id="sectionLabel"></div>
                <div id="cardContent"></div>
                <div></div>
            </div>
        </div>
    </div>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script>
        // ============================================
        // QUESTIONS CONFIGURATION
        // ============================================
        const QUESTIONS = [
            // Morning (m1-m13, skipping m2 and m11 which were removed)
            { id: 'm1', section: 'morning', text: 'make bed?', color: 'M' },
            { id: 'm3', section: 'morning', text: 'colostrum AM?', color: 'C' },
            { id: 'm4', section: 'morning', text: 'morning walk?', color: 'M' },
            { id: 'm5', section: 'morning', text: 'yogurt / fruit / granola?', color: 'C' },
            { id: 'm6', section: 'morning', text: 'journal?', color: 'M' },
            { id: 'm7', section: 'morning', text: 'shower AM?', color: 'C' },
            { id: 'm8', section: 'morning', text: 'hair AM?', color: 'C' },
            { id: 'm9', section: 'morning', text: 'shave?', color: 'M' },
            { id: 'm10', section: 'morning', text: 'face / ear AM?', color: 'C' },
            { id: 'm12', section: 'morning', text: 'rise at 6:30?', color: 'M' },
            { id: 'm13', section: 'morning', text: 'daily vitamin?', color: 'M' },
            
            // Evening (e1-e10, skipping e6 and e7 which were removed)
            { id: 'e1', section: 'evening', text: 'colostrum PM?', color: 'C' },
            { id: 'e2', section: 'evening', text: 'evening workout?', color: 'C' },
            { id: 'e3', section: 'evening', text: 'shower PM?', color: 'C' },
            { id: 'e4', section: 'evening', text: 'hair PM?', color: 'C' },
            { id: 'e5', section: 'evening', text: 'face / ear PM?', color: 'C' },
            { id: 'e10', section: 'evening', text: 'drink bottle of water?', color: 'C' },
            { id: 'e8', section: 'evening', text: 'read?', color: 'M' },
            { id: 'e9', section: 'evening', text: 'recline at 10:30?', color: 'M' },
            
            // Daily substances (d1-d5)
            { id: 'd1', section: 'daily', text: 'nicotine free?', color: 'M', substanceType: 'harmful' },
            { id: 'd2', section: 'daily', text: 'cannabis free?', color: 'M', substanceType: 'harmful' },
            { id: 'd3', section: 'daily', text: 'alcohol free?', color: 'M', substanceType: 'harmful' },
            { id: 'd4', section: 'daily', text: 'caffeine?', color: 'M' },
            { id: 'd5', section: 'daily', text: 'nootropics?', color: 'M', substanceType: 'nootropic' },
            
            // Daily social (d6-d9)
            { id: 'd6', section: 'daily', text: 'connect with friends?', color: 'Y' },
            { id: 'd7', section: 'daily', text: 'connect with family?', color: 'Y' },
            { id: 'd8', section: 'daily', text: 'quality time with Maria?', color: 'Y' },
            { id: 'd9', section: 'daily', text: 'take care of Peppa?', color: 'Y' },
            
            // Daily intimacy (d10-d11)
            { id: 'd10', section: 'daily', text: 'sex?', color: 'W', intimacyType: 'sex' },
            { id: 'd11', section: 'daily', text: 'self sex?', color: 'W', intimacyType: 'selfSex' },
            
            // Relationship effort (d12-d16)
            { id: 'd12', section: 'daily', text: 'initiated affection?', color: 'Y' },
            { id: 'd13', section: 'daily', text: 'expressed appreciation?', color: 'Y' },
            { id: 'd14', section: 'daily', text: 'let something go?', color: 'Y' },
            { id: 'd15', section: 'daily', text: 'real conversation?', color: 'Y' },
            { id: 'd16', section: 'daily', text: 'conflict with Maria?', color: 'Y', substanceType: 'conflict' },
            
            // Home (d17)
            { id: 'd17', section: 'daily', text: 'left it better?', color: 'C' },
            
            // Hours (h1-h5)
            { id: 'h1', section: 'hours', text: 'pinkProportion hours', color: 'M' },
            { id: 'h2', section: 'hours', text: 'FR studio hours', color: 'C' },
            { id: 'h3', section: 'hours', text: 'FR creative hours', color: 'Y' },
            { id: 'h4', section: 'hours', text: 'health hours', color: 'W' },
            { id: 'h5', section: 'hours', text: 'sleep (last night)', color: 'M', barColor: 'black' },
            
            // Text and rating
            { id: 'text', section: 'text', text: 'daily response', color: 'W' },
            { id: 'rating', section: 'rating', text: 'daily rating', color: 'W' }
        ];

        // ============================================
        // APP CONFIGURATION
        // ============================================
        const CLIENT_ID = '785091900263-bqe75ticj4pr0uovtb1b0c5d8ogpnvm8.apps.googleusercontent.com';
        const SPREADSHEET_ID = '1JfphEjMpGi16ALOGdbLIu5II1Ns5eRjUxdUb9HLTFu8';
        const SCOPES = 'https://www.googleapis.com/auth/spreadsheets';

        const COLOR_MAP = {
            'C': '#00FFFF',  // Cyan
            'M': '#FF00FF',  // Magenta
            'Y': '#FFFF00',  // Yellow
            'W': '#FFFFFF'   // White
        };

        const SECTION_LABELS = {
            'morning': 'Morning Checklist',
            'evening': 'Evening Checklist',
            'daily': 'Daily Checklist',
            'hours': 'Hours Tracking',
            'text': 'Daily Response',
            'rating': 'Daily Rating'
        };

        // SVG Icons
        const SUN_ICON = '<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>';
        
        const MOON_ICON = '<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>';
        
        const MIC_ICON = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>';

        // ============================================
        // APP STATE
        // ============================================
        let accessToken = null;
        let tokenClient = null;
        let currentQuestionIndex = 0;
        let responses = {};
        let dragStartX = 0;
        let dragOffset = 0;
        let isDragging = false;
        let timeRange = '1w'; // '1w', '1m', or 'all'
        let chartMode = 'percent'; // 'percent', 'hours', or 'loc'
        let quizData = [];
        let globe = null;
        let recognition = null;
        let isRecording = false;
        let isAuthInitialized = false;
        
        // Chart state for click detection
        let chartDataPoints = [];
        let chartPadding = { top: 20, right: 20, bottom: 40, left: 45 };
        let chartWidth = 0;
        let chartHeight = 0;

        // Process questions to add type information
        const questions = QUESTIONS.map(q => {
            let type = 'yesno';
            if (q.section === 'rating') type = 'rating';
            if (q.section === 'text') type = 'text';
            if (q.section === 'hours') type = 'hours';
            
            return {
                ...q,
                type: type
            };
        });

        // ============================================
        // CHART DRAWING UTILITIES
        // ============================================
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 255 };
        }

        function rgba(hex, alpha) {
            const { r, g, b } = hexToRgb(hex);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function setupCanvas(canvas) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            return { ctx, width: rect.width, height: rect.height };
        }

        function getControlPoints(points, tension = 0.3) {
            const cp = [];
            for (let i = 0; i < points.length; i++) {
                const p0 = points[i === 0 ? 0 : i - 1];
                const p1 = points[i];
                const p2 = points[i === points.length - 1 ? i : i + 1];
                const p3 = points[i >= points.length - 2 ? points.length - 1 : i + 2];
                cp.push({
                    cp1x: p1.x + (p2.x - p0.x) * tension,
                    cp1y: p1.y + (p2.y - p0.y) * tension,
                    cp2x: p2.x - (p3.x - p1.x) * tension,
                    cp2y: p2.y - (p3.y - p1.y) * tension
                });
            }
            return cp;
        }

        function drawSmoothLine(ctx, points) {
            if (points.length < 2) return;
            const cp = getControlPoints(points);
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 0; i < points.length - 1; i++) {
                ctx.bezierCurveTo(cp[i].cp1x, cp[i].cp1y, cp[i].cp2x, cp[i].cp2y, points[i + 1].x, points[i + 1].y);
            }
            ctx.stroke();
        }

        function drawSmoothArea(ctx, topPoints, bottomPoints) {
            if (topPoints.length < 2) return;
            const cpTop = getControlPoints(topPoints);
            const bottomRev = [...bottomPoints].reverse();
            const cpBot = getControlPoints(bottomRev);

            ctx.beginPath();
            ctx.moveTo(topPoints[0].x, topPoints[0].y);
            for (let i = 0; i < topPoints.length - 1; i++) {
                ctx.bezierCurveTo(cpTop[i].cp1x, cpTop[i].cp1y, cpTop[i].cp2x, cpTop[i].cp2y, topPoints[i + 1].x, topPoints[i + 1].y);
            }
            ctx.lineTo(bottomRev[0].x, bottomRev[0].y);
            for (let i = 0; i < bottomRev.length - 1; i++) {
                ctx.bezierCurveTo(cpBot[i].cp1x, cpBot[i].cp1y, cpBot[i].cp2x, cpBot[i].cp2y, bottomRev[i + 1].x, bottomRev[i + 1].y);
            }
            ctx.closePath();
            ctx.fill();
        }

        // ============================================
        // GOOGLE AUTH
        // ============================================
        function initializeGoogleAuth() {
            const loginBtn = document.querySelector('.btn');
            if (loginBtn) {
                loginBtn.disabled = true;
                loginBtn.textContent = 'loading...';
            }

            const waitForGoogleAPIs = setInterval(() => {
                if (typeof google !== 'undefined' && google.accounts) {
                    clearInterval(waitForGoogleAPIs);
                    initializeAPIs();
                }
            }, 100);
        }

        function initializeAPIs() {
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: async (response) => {
                        if (response.error) {
                            console.error('Auth error:', response.error);
                            alert('Authentication failed. Please try again.');
                            return;
                        }
                        accessToken = response.access_token;
                        await loadSheetData();
                        showScreen('chartScreen');
                    }
                });

                isAuthInitialized = true;
                
                const loginBtn = document.querySelector('.btn');
                if (loginBtn) {
                    loginBtn.disabled = false;
                    loginBtn.textContent = 'sign in with google';
                }

                console.log('Google Auth initialized successfully');
            } catch (error) {
                console.error('Error initializing Google Auth:', error);
                const loginBtn = document.querySelector('.btn');
                if (loginBtn) {
                    loginBtn.disabled = false;
                    loginBtn.textContent = 'sign in with google (retry)';
                }
            }
        }

        window.handleLogin = function() {
            if (!isAuthInitialized || !tokenClient) {
                alert('Authentication is still loading. Please wait a moment and try again.');
                return;
            }
            tokenClient.requestAccessToken({ prompt: 'consent' });
        };

        // ============================================
        // DATA MANAGEMENT
        // ============================================
        async function loadSheetData() {
            try {
                const response = await fetch(
                    `https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/Sheet1!A:ZZ`,
                    {
                        headers: {
                            Authorization: `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();

                if (data.values && data.values.length > 1) {
                    const headers = data.values[0];
                    quizData = data.values.slice(1).map(row => {
                        const entry = {};
                        headers.forEach((header, index) => {
                            entry[header] = row[index] || '';
                        });
                        return entry;
                    });
                } else {
                    quizData = [];
                }

                updateChart();
            } catch (error) {
                console.error('Error loading sheet data:', error);
                quizData = [];
                updateChart();
            }
        }

        async function saveToSheet(data) {
            try {
                const checkResponse = await fetch(
                    `https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/Sheet1!1:1`,
                    {
                        headers: {
                            Authorization: `Bearer ${accessToken}`
                        }
                    }
                );

                const checkData = await checkResponse.json();
                let existingHeaders = checkData.values?.[0] || [];

                const expectedHeaders = ['timestamp', ...questions.map(q => q.id), 'loc'];

                const mergedHeaders = [...existingHeaders];
                expectedHeaders.forEach(header => {
                    if (!mergedHeaders.includes(header)) {
                        mergedHeaders.push(header);
                    }
                });

                if (mergedHeaders.length !== existingHeaders.length || existingHeaders.length === 0) {
                    console.log('Updating headers:', mergedHeaders);
                    await fetch(
                        `https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/Sheet1!1:1?valueInputOption=RAW`,
                        {
                            method: 'PUT',
                            headers: {
                                Authorization: `Bearer ${accessToken}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                values: [mergedHeaders]
                            })
                        }
                    );
                }

                const row = mergedHeaders.map(header => {
                    if (data[header] !== undefined) {
                        return data[header];
                    }
                    return '';
                });

                await fetch(
                    `https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/Sheet1!A:ZZ:append?valueInputOption=RAW`,
                    {
                        method: 'POST',
                        headers: {
                            Authorization: `Bearer ${accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            values: [row]
                        })
                    }
                );

                console.log('Data saved successfully');
                await loadSheetData();
            } catch (error) {
                console.error('Error saving to sheet:', error);
            }
        }

        // ============================================
        // GEOLOCATION
        // ============================================
        function getLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    resolve(null);
                    return;
                }
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve(`${position.coords.latitude},${position.coords.longitude}`);
                    },
                    (error) => {
                        console.log('Geolocation error:', error);
                        resolve(null);
                    },
                    { timeout: 5000, enableHighAccuracy: true }
                );
            });
        }

        // ============================================
        // UI NAVIGATION
        // ============================================
        function showScreen(screenId) {
            if (screenId !== 'quizScreen') {
                stopRecording();
                responses = {};
            }

            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('chartScreen').classList.remove('active');
            document.getElementById('quizScreen').classList.remove('active');

            if (screenId === 'chartScreen') {
                document.getElementById('chartScreen').classList.add('active');
                // Redraw chart after screen is visible
                setTimeout(updateChart, 50);
            } else if (screenId === 'quizScreen') {
                document.getElementById('quizScreen').classList.add('active');
            } else {
                document.getElementById(screenId).classList.remove('hidden');
            }
        }

        function setTimeRange(range) {
            timeRange = range;
            document.getElementById('toggle1w').classList.toggle('active', range === '1w');
            document.getElementById('toggle1m').classList.toggle('active', range === '1m');
            document.getElementById('toggleAll').classList.toggle('active', range === 'all');
            updateChart();
        }

        function setChartMode(mode) {
            chartMode = mode;
            document.getElementById('viewPercent').classList.toggle('active', mode === 'percent');
            document.getElementById('viewHours').classList.toggle('active', mode === 'hours');
            document.getElementById('viewLoc').classList.toggle('active', mode === 'loc');
            
            const canvas = document.getElementById('myChart');
            const globeViz = document.getElementById('globeViz');
            const globeLegend = document.getElementById('globeLegend');
            const dateRange = document.getElementById('dateRange');
            
            if (mode === 'loc') {
                canvas.style.display = 'none';
                globeViz.classList.add('active');
                globeLegend.classList.add('active');
                dateRange.style.display = 'none';
                setTimeout(() => {
                    updateGlobe();
                }, 100);
            } else {
                canvas.style.display = 'block';
                globeViz.classList.remove('active');
                globeLegend.classList.remove('active');
                dateRange.style.display = 'flex';
                updateChart();
            }
        }

        // ============================================
        // DATA POPUP
        // ============================================
        function initPopupDragHandlers() {
            const popup = document.getElementById('dataPopup');
            let popupDragStartX = 0;
            let popupDragOffset = 0;
            let popupIsDragging = false;

            const startPopupDrag = (e) => {
                if (e.target.id === 'dataPopup') {
                    popupIsDragging = true;
                    popupDragStartX = e.touches ? e.touches[0].clientX : e.clientX;
                    popupDragOffset = 0;
                }
            };

            const popupDrag = (e) => {
                if (!popupIsDragging) return;
                const currentX = e.touches ? e.touches[0].clientX : e.clientX;
                popupDragOffset = currentX - popupDragStartX;
            };

            const endPopupDrag = () => {
                if (!popupIsDragging) return;

                if (Math.abs(popupDragOffset) > 100) {
                    closeDataPopup();
                }

                popupIsDragging = false;
                popupDragOffset = 0;
            };

            popup.addEventListener('touchstart', startPopupDrag, { passive: false });
            popup.addEventListener('touchmove', popupDrag, { passive: false });
            popup.addEventListener('touchend', endPopupDrag);
            popup.addEventListener('mousedown', startPopupDrag);
            document.addEventListener('mousemove', popupDrag);
            document.addEventListener('mouseup', endPopupDrag);
        }

        function showDataPopup(timestamp) {
            const entry = quizData.find(e => e.timestamp === timestamp);
            if (!entry) return;

            const popup = document.getElementById('dataPopup');
            const content = document.getElementById('popupContent');

            let html = `<div class="popup-timestamp">${new Date(timestamp).toLocaleString()}</div>`;

            const sections = {};
            questions.forEach(q => {
                if (!sections[q.section]) {
                    sections[q.section] = [];
                }
                sections[q.section].push(q);
            });

            Object.keys(sections).forEach(sectionKey => {
                html += `<div class="popup-section">`;
                html += `<div class="popup-section-title">${SECTION_LABELS[sectionKey]}</div>`;
                
                sections[sectionKey].forEach(q => {
                    const value = entry[q.id] || '-';
                    const color = COLOR_MAP[q.color];
                    
                    if (q.type === 'rating') {
                        html += `<div class="popup-item"><span class="popup-label">${q.text}:</span> <span style="color: ${color}">${value}</span></div>`;
                    } else if (q.type === 'text') {
                        html += `<div class="popup-item"><span class="popup-label">${q.text}:</span> <span style="color: ${color}">${value || 'none'}</span></div>`;
                    } else if (q.type === 'hours') {
                        html += `<div class="popup-item"><span class="popup-label">${q.text}:</span> <span style="color: ${color}">${value}h</span></div>`;
                    } else {
                        html += `<div class="popup-item"><span class="popup-label">${q.text}:</span> <span style="color: ${color}">${value}</span></div>`;
                    }
                });
                
                html += `</div>`;
            });

            if (entry.loc) {
                html += `<div class="popup-section">`;
                html += `<div class="popup-section-title">Location</div>`;
                html += `<div class="popup-item">${entry.loc}</div>`;
                html += `</div>`;
            }

            content.innerHTML = html;
            popup.classList.add('active');
        }

        function closeDataPopup() {
            document.getElementById('dataPopup').classList.remove('active');
        }

        // ============================================
        // GLOBE RENDERING
        // ============================================
        function getGlobeColor(t) {
            if (t < 0.5) {
                const r = Math.round(0 + (255 - 0) * (t * 2));
                const g = Math.round(255 - (255 - 0) * (t * 2));
                const b = 255;
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                const t2 = (t - 0.5) * 2;
                const r = 255;
                const g = Math.round(0 + (255 - 0) * t2);
                const b = Math.round(255 - (255 - 0) * t2);
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        function updateGlobe() {
            const container = document.getElementById('globeViz');
            
            const entriesWithLoc = quizData
                .filter(entry => entry.loc && entry.loc.includes(','))
                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            const points = entriesWithLoc.map((entry, index) => {
                const [lat, lng] = entry.loc.split(',').map(Number);
                const t = entriesWithLoc.length > 1 ? index / (entriesWithLoc.length - 1) : 1;
                const color = getGlobeColor(t);
                
                const rating = parseFloat(entry.rating) || 0;
                const size = ((rating + 2) / 4) * 0.7 + 0.3;
                
                return {
                    lat: lat,
                    lng: lng,
                    size: size,
                    color: color,
                    label: `${new Date(entry.timestamp).toLocaleDateString()}\nrating: ${rating > 0 ? '+' : ''}${rating}`
                };
            });

            if (globe) {
                globe._destructor && globe._destructor();
                container.innerHTML = '';
                globe = null;
            }

            globe = Globe()
                .globeImageUrl('https://unpkg.com/three-globe/example/img/earth-dark.jpg')
                .bumpImageUrl('https://unpkg.com/three-globe/example/img/earth-topology.png')
                .backgroundColor('#0D0D0D')
                .pointsData(points)
                .pointLat('lat')
                .pointLng('lng')
                .pointColor('color')
                .pointAltitude(0.01)
                .pointRadius('size')
                .pointLabel('label')
                .atmosphereColor('#333333')
                .atmosphereAltitude(0.15)
                (container);

            if (entriesWithLoc.length > 0) {
                const latest = entriesWithLoc[entriesWithLoc.length - 1];
                const [latestLat, latestLng] = latest.loc.split(',').map(Number);
                globe.pointOfView({ lat: latestLat, lng: latestLng, altitude: 1.5 }, 1000);
            } else {
                globe.pointOfView({ lat: 20, lng: 0, altitude: 2.5 }, 1000);
            }
        }

        // ============================================
        // CHART RENDERING (Custom Canvas)
        // ============================================
        function updateChart() {
            if (chartMode === 'loc') return;
            
            const canvas = document.getElementById('myChart');
            const { ctx, width, height } = setupCanvas(canvas);
            
            // Store dimensions for click handling
            chartWidth = width;
            chartHeight = height;
            
            const padding = chartPadding;
            const chartW = width - padding.left - padding.right;
            const chartH = height - padding.top - padding.bottom;

            // Clear canvas
            ctx.fillStyle = '#0D0D0D';
            ctx.fillRect(0, 0, width, height);

            // Filter data by time range
            let filteredData = [...quizData].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (timeRange !== 'all' && filteredData.length > 0) {
                const now = new Date();
                let cutoffDate = new Date();
                
                if (timeRange === '1w') {
                    cutoffDate.setDate(now.getDate() - 7);
                } else if (timeRange === '1m') {
                    cutoffDate.setDate(now.getDate() - 30);
                }
                
                filteredData = filteredData.filter(entry => new Date(entry.timestamp) >= cutoffDate);
            }

            if (filteredData.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '14px Karla';
                ctx.textAlign = 'center';
                ctx.fillText('No data for this time range', width / 2, height / 2);
                document.getElementById('dateStart').textContent = '';
                document.getElementById('dateEnd').textContent = '';
                return;
            }

            // Build chart data
            let chartData;
            
            if (chartMode === 'percent') {
                chartData = filteredData.map(entry => {
                    const cyanQuestions = questions.filter(q => q.color === 'C' && q.type === 'yesno' && !q.intimacyType);
                    const magentaQuestions = questions.filter(q => q.color === 'M' && q.type === 'yesno' && !q.intimacyType);
                    const yellowQuestions = questions.filter(q => q.color === 'Y' && q.type === 'yesno' && !q.intimacyType);

                    const cyanAnswered = cyanQuestions.filter(q => entry[q.id] === 'yes' || entry[q.id] === 'no').length;
                    const magentaAnswered = magentaQuestions.filter(q => entry[q.id] === 'yes' || entry[q.id] === 'no').length;
                    const yellowAnswered = yellowQuestions.filter(q => entry[q.id] === 'yes' || entry[q.id] === 'no').length;

                    const cyanYes = cyanQuestions.filter(q => entry[q.id] === 'yes').length;
                    const magentaYes = magentaQuestions.filter(q => entry[q.id] === 'yes').length;
                    const yellowYes = yellowQuestions.filter(q => entry[q.id] === 'yes').length;

                    const cyanPercent = cyanAnswered > 0 ? (cyanYes / cyanAnswered) * 100 : null;
                    const magentaPercent = magentaAnswered > 0 ? (magentaYes / magentaAnswered) * 100 : null;
                    const yellowPercent = yellowAnswered > 0 ? (yellowYes / yellowAnswered) * 100 : null;

                    const rating = parseFloat(entry['rating']);
                    let ratingPercent = isNaN(rating) || entry['rating'] === '' ? null : ((rating + 2) / 4) * 100;

                    const harmfulSubstanceQuestions = questions.filter(q => q.substanceType === 'harmful');
                    const hasSubstanceUse = harmfulSubstanceQuestions.some(q => entry[q.id] === 'no');

                    const nootropicQuestions = questions.filter(q => q.substanceType === 'nootropic');
                    const hasNootropics = nootropicQuestions.some(q => entry[q.id] === 'yes');

                    const conflictQuestions = questions.filter(q => q.substanceType === 'conflict');
                    const hasConflict = conflictQuestions.some(q => entry[q.id] === 'yes');

                    const hasSex = entry['d10'] === 'yes';
                    const hasSelfSex = entry['d11'] === 'yes';

                    return {
                        originalTimestamp: entry.timestamp,
                        cyan: cyanPercent,
                        magenta: magentaPercent,
                        yellow: yellowPercent,
                        rating: ratingPercent,
                        hasSubstanceUse,
                        hasNootropics,
                        hasConflict,
                        hasSex,
                        hasSelfSex
                    };
                });

                drawPercentChart(ctx, chartData, padding, chartW, chartH);
            } else {
                chartData = filteredData.map(entry => {
                    const sleepHours = parseFloat(entry['h5']) || 0;
                    const healthHours = parseFloat(entry['h4']) || 0;
                    const studioHours = parseFloat(entry['h2']) || 0;
                    const pinkHours = parseFloat(entry['h1']) || 0;
                    const creativeHours = parseFloat(entry['h3']) || 0;

                    const rating = parseFloat(entry['rating']);
                    let ratingScaled = isNaN(rating) || entry['rating'] === '' ? null : ((rating + 2) / 4) * 24;

                    return {
                        originalTimestamp: entry.timestamp,
                        sleep: sleepHours,
                        health: healthHours,
                        studio: studioHours,
                        pink: pinkHours,
                        creative: creativeHours,
                        rating: ratingScaled
                    };
                });

                drawHoursChart(ctx, chartData, padding, chartW, chartH);
            }

            // Store data points for click detection
            chartDataPoints = chartData;

            // Update date range display
            if (filteredData.length > 0) {
                const startDate = new Date(filteredData[0].timestamp);
                const endDate = new Date(filteredData[filteredData.length - 1].timestamp);
                const formatDate = (d) => `${d.getMonth() + 1}/${d.getDate()}/${String(d.getFullYear()).slice(-2)}`;
                document.getElementById('dateStart').textContent = formatDate(startDate);
                document.getElementById('dateEnd').textContent = formatDate(endDate);
            }
        }

        function drawPercentChart(ctx, data, padding, chartW, chartH) {
            const width = chartW + padding.left + padding.right;
            const height = chartH + padding.top + padding.bottom;

            const colors = {
                cyan: '#00FFFF',
                magenta: '#FF00FF',
                yellow: '#FFFF00',
                white: '#FFFFFF',
                red: '#FF0000',
                green: '#00FF00'
            };

            // Y-axis labels
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.font = '10px Karla';
            ctx.textAlign = 'right';
            [100, 75, 50, 25, 0].forEach(v => {
                const y = padding.top + chartH - (v / 100) * chartH;
                ctx.fillText(v, padding.left - 8, y + 3);
            });

            // Subtle grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            [100, 75, 50, 25, 0].forEach(v => {
                const y = padding.top + chartH - (v / 100) * chartH;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartW, y);
                ctx.stroke();
            });

            // Draw indicator bands with lead-in and fade-out
            const dayWidth = data.length > 1 ? chartW / (data.length - 1) : chartW;
            const leadIn = dayWidth / 8;  // ~3 hours before
            const fadeOut = dayWidth / 4; // 6 hours after
            const totalWidth = leadIn + fadeOut;
            const peakPos = leadIn / totalWidth; // where 10% opacity peaks

            data.forEach((d, i) => {
                const x = padding.left + (data.length > 1 ? (i / (data.length - 1)) * chartW : chartW / 2);
                const startX = x - leadIn;

                // Red gradient band - substance
                if (d.hasSubstanceUse) {
                    const grad = ctx.createLinearGradient(startX, 0, startX + totalWidth, 0);
                    grad.addColorStop(0, rgba(colors.red, 0));
                    grad.addColorStop(peakPos, rgba(colors.red, 0.1));
                    grad.addColorStop(1, rgba(colors.red, 0));
                    ctx.fillStyle = grad;
                    ctx.fillRect(startX, padding.top, totalWidth, chartH);
                }

                // Red striped gradient band - conflict
                if (d.hasConflict) {
                    const grad = ctx.createLinearGradient(startX, 0, startX + totalWidth, 0);
                    grad.addColorStop(0, rgba(colors.red, 0));
                    grad.addColorStop(peakPos, rgba(colors.red, 0.1));
                    grad.addColorStop(1, rgba(colors.red, 0));
                    ctx.fillStyle = grad;
                    ctx.save();
                    ctx.beginPath();
                    for (let yy = padding.top; yy < padding.top + chartH; yy += 10) {
                        ctx.rect(startX, yy, totalWidth, 5);
                    }
                    ctx.clip();
                    ctx.fillRect(startX, padding.top, totalWidth, chartH);
                    ctx.restore();
                }

                // Green gradient band - nootropic
                if (d.hasNootropics) {
                    const grad = ctx.createLinearGradient(startX, 0, startX + totalWidth, 0);
                    grad.addColorStop(0, rgba(colors.green, 0));
                    grad.addColorStop(peakPos, rgba(colors.green, 0.1));
                    grad.addColorStop(1, rgba(colors.green, 0));
                    ctx.fillStyle = grad;
                    ctx.fillRect(startX, padding.top, totalWidth, chartH);
                }

                // White gradient band - sex
                if (d.hasSex) {
                    const grad = ctx.createLinearGradient(startX, 0, startX + totalWidth, 0);
                    grad.addColorStop(0, rgba(colors.white, 0));
                    grad.addColorStop(peakPos, rgba(colors.white, 0.1));
                    grad.addColorStop(1, rgba(colors.white, 0));
                    ctx.fillStyle = grad;
                    ctx.fillRect(startX, padding.top, totalWidth, chartH);
                }

                // White striped gradient band - self sex
                if (d.hasSelfSex) {
                    const grad = ctx.createLinearGradient(startX, 0, startX + totalWidth, 0);
                    grad.addColorStop(0, rgba(colors.white, 0));
                    grad.addColorStop(peakPos, rgba(colors.white, 0.1));
                    grad.addColorStop(1, rgba(colors.white, 0));
                    ctx.fillStyle = grad;
                    ctx.save();
                    ctx.beginPath();
                    for (let yy = padding.top + 5; yy < padding.top + chartH; yy += 10) {
                        ctx.rect(startX, yy, totalWidth, 5);
                    }
                    ctx.clip();
                    ctx.fillRect(startX, padding.top, totalWidth, chartH);
                    ctx.restore();
                }
            });

            // Color lines for gradient fills (cyan, magenta, yellow only - not white)
            const colorLines = [
                { key: 'yellow', color: colors.yellow },
                { key: 'magenta', color: colors.magenta },
                { key: 'cyan', color: colors.cyan }
            ];

            const getPoints = (key) => data.map((d, i) => {
                const val = d[key];
                return {
                    x: padding.left + (data.length > 1 ? (i / (data.length - 1)) * chartW : chartW / 2),
                    y: val !== null ? padding.top + chartH - (val / 100) * chartH : null,
                    index: i
                };
            }).filter(p => p.y !== null);

            const colorPointSets = colorLines.map(l => ({ ...l, points: getPoints(l.key) }));

            // Gradient fills between color lines only (no white)
            for (let i = 0; i < colorPointSets.length - 1; i++) {
                const upper = colorPointSets[i + 1];
                const lower = colorPointSets[i];
                if (upper.points.length > 1 && lower.points.length > 1) {
                    const grad = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartH);
                    grad.addColorStop(0, rgba(upper.color, 0.25));
                    grad.addColorStop(1, rgba(lower.color, 0.08));
                    ctx.fillStyle = grad;
                    drawSmoothArea(ctx, upper.points, lower.points);
                }
            }

            // All lines including white (rating)
            const allLines = [
                { key: 'rating', color: colors.white },
                ...colorLines
            ];

            const allPointSets = allLines.map(l => ({ ...l, points: getPoints(l.key) }));

            // Draw lines
            allPointSets.forEach(({ points, color }) => {
                if (points.length > 1) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.5;
                    drawSmoothLine(ctx, points);
                }
            });

            // Draw dots (smaller for dense data)
            const dotSize = data.length <= 7 ? 4 : data.length <= 30 ? 2.5 : 1.5;
            allPointSets.forEach(({ points, color }) => {
                points.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, dotSize, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                });
            });
        }

        function drawHoursChart(ctx, data, padding, chartW, chartH) {
            // Y-axis labels
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.font = '10px Karla';
            ctx.textAlign = 'right';
            [24, 12, 0].forEach(v => {
                const y = padding.top + chartH - (v / 24) * chartH;
                ctx.fillText(v + 'h', padding.left - 8, y + 3);
            });

            // Subtle grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            [24, 12, 0].forEach(v => {
                const y = padding.top + chartH - (v / 24) * chartH;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartW, y);
                ctx.stroke();
            });

            const categories = [
                { key: 'sleep', color: '#1a1a2e' },
                { key: 'health', color: '#FFFFFF' },
                { key: 'studio', color: '#00FFFF' },
                { key: 'pink', color: '#FF00FF' },
                { key: 'creative', color: '#FFFF00' }
            ];

            const barWidth = Math.max(3, Math.min(20, (chartW / data.length) * 0.6));
            const barGap = chartW / data.length;

            data.forEach((d, i) => {
                const x = padding.left + i * barGap + (barGap - barWidth) / 2;
                let y = padding.top + chartH;

                categories.forEach((cat, ci) => {
                    const hours = d[cat.key];
                    const h = (hours / 24) * chartH;
                    if (h < 1) return;
                    y -= h;

                    const rgb = hexToRgb(cat.color);
                    const grad = ctx.createLinearGradient(x, y, x, y + h);
                    grad.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 1)`);
                    grad.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.6)`);
                    ctx.fillStyle = grad;

                    const isTop = ci === categories.length - 1 || categories.slice(ci + 1).every(c => d[c.key] < 0.1);
                    const radius = isTop ? Math.min(barWidth / 2, 4) : 0;

                    if (radius > 0) {
                        ctx.beginPath();
                        ctx.moveTo(x, y + h);
                        ctx.lineTo(x, y + radius);
                        ctx.quadraticCurveTo(x, y, x + radius, y);
                        ctx.lineTo(x + barWidth - radius, y);
                        ctx.quadraticCurveTo(x + barWidth, y, x + barWidth, y + radius);
                        ctx.lineTo(x + barWidth, y + h);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.fillRect(x, y, barWidth, h);
                    }
                });
            });
        }

        // Chart click handler
        function handleChartClick(e) {
            if (chartMode === 'loc' || chartDataPoints.length === 0) return;
            
            const canvas = document.getElementById('myChart');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX / (window.devicePixelRatio || 1);
            const y = (e.clientY - rect.top) * scaleY / (window.devicePixelRatio || 1);
            
            const chartW = chartWidth - chartPadding.left - chartPadding.right;
            
            // Find closest data point
            let closestIndex = -1;
            let closestDist = Infinity;
            
            chartDataPoints.forEach((d, i) => {
                const pointX = chartPadding.left + (chartDataPoints.length > 1 ? (i / (chartDataPoints.length - 1)) * chartW : chartW / 2);
                const dist = Math.abs(x - pointX);
                if (dist < closestDist && dist < 30) {
                    closestDist = dist;
                    closestIndex = i;
                }
            });
            
            if (closestIndex >= 0) {
                showDataPopup(chartDataPoints[closestIndex].originalTimestamp);
            }
        }

        // ============================================
        // QUIZ LOGIC
        // ============================================
        function startQuiz() {
            currentQuestionIndex = 0;
            responses = {};
            showScreen('quizScreen');
            renderQuestion();
            initCardDragHandlers();
        }

        function initCardDragHandlers() {
            const card = document.getElementById('card');
            if (!card) return;

            card.removeEventListener('mousedown', startDrag);
            card.removeEventListener('touchstart', startDrag);

            card.addEventListener('mousedown', startDrag);
            card.addEventListener('touchstart', startDrag, { passive: false });

            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
        }

        function renderQuestion() {
            const question = questions[currentQuestionIndex];
            const card = document.getElementById('card');
            const sectionLabel = document.getElementById('sectionLabel');
            const cardContent = document.getElementById('cardContent');
            const progressBar = document.getElementById('progressBar');

            if (question.type !== 'text') {
                stopRecording();
            }

            card.style.backgroundColor = '#0D0D0D';
            card.style.borderColor = COLOR_MAP[question.color];
            card.style.transform = 'none';

            let icon = '';
            if (question.section === 'morning') icon = SUN_ICON;
            else if (question.section === 'evening') icon = MOON_ICON;

            sectionLabel.innerHTML = icon + `<span>${SECTION_LABELS[question.section]}</span>`;
            sectionLabel.style.color = COLOR_MAP[question.color];

            const progress = (currentQuestionIndex / questions.length) * 100;
            progressBar.style.width = `${progress}%`;

            const colorHex = COLOR_MAP[question.color];

            if (question.type === 'yesno') {
                cardContent.innerHTML = `<div class="question-text" style="color: ${colorHex}">${question.text}</div>`;
            } else if (question.type === 'text') {
                cardContent.innerHTML = `
                    <div class="text-input-container">
                        <textarea 
                            id="textInput" 
                            class="text-input" 
                            placeholder="tap to type or use microphone..."
                        ></textarea>
                        <div class="input-controls">
                            <button id="micBtn" class="mic-btn" onclick="toggleRecording()">
                                ${MIC_ICON}
                                <span>record</span>
                            </button>
                            <button class="submit-btn" onclick="submitText()">
                                submit
                            </button>
                        </div>
                    </div>
                `;
            } else if (question.type === 'rating') {
                const values = [2, 1, 0, -1, -2];
                cardContent.innerHTML = `<div class="rating-container">
                    ${values.map(val => `
                        <div class="rating-circle" 
                             data-value="${val}"
                             style="border-color: ${colorHex}; color: ${colorHex};"
                             onclick="selectRating(${val})">
                            ${val > 0 ? '+' + val : val}
                        </div>
                    `).join('')}
                </div>`;
            } else if (question.type === 'hours') {
                cardContent.innerHTML = `
                    <div class="slider-container">
                        <div class="question-text" style="color: ${colorHex}; font-size: 24px; margin-bottom: 20px;">${question.text}</div>
                        <div class="slider-value" id="sliderValue" style="color: ${colorHex}">0</div>
                        <div class="slider-wrapper">
                            <input 
                                type="range" 
                                min="0" 
                                max="12" 
                                value="0" 
                                class="hour-slider" 
                                id="hourSlider"
                                style="background: linear-gradient(to right, ${colorHex} 0%, #1A1A1A 0%);"
                                oninput="updateSliderValue(this.value, '${colorHex}')"
                            />
                            <div class="slider-labels">
                                <span>0</span>
                                <span>6</span>
                                <span>12</span>
                            </div>
                        </div>
                        <button class="submit-btn" onclick="submitHours()" style="margin-top: 40px;">
                            submit
                        </button>
                    </div>
                `;
            }
        }

        function updateSliderValue(value, color) {
            document.getElementById('sliderValue').textContent = value;
            const slider = document.getElementById('hourSlider');
            const percentage = (value / 12) * 100;
            slider.style.background = `linear-gradient(to right, ${color} ${percentage}%, #1A1A1A ${percentage}%)`;
        }

        function submitText() {
            const textInput = document.getElementById('textInput');
            const question = questions[currentQuestionIndex];
            responses[question.id] = textInput.value.trim();
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                renderQuestion();
            } else {
                completeQuiz();
            }
        }

        function submitHours() {
            const slider = document.getElementById('hourSlider');
            const question = questions[currentQuestionIndex];
            responses[question.id] = slider.value;
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                renderQuestion();
            } else {
                completeQuiz();
            }
        }

        function selectRating(value) {
            const question = questions[currentQuestionIndex];
            const circles = document.querySelectorAll('.rating-circle');
            
            circles.forEach(circle => {
                const circleValue = parseInt(circle.getAttribute('data-value'));
                if (circleValue <= value) {
                    circle.style.backgroundColor = COLOR_MAP[question.color];
                }
            });

            responses[question.id] = value;

            setTimeout(() => {
                currentQuestionIndex++;
                if (currentQuestionIndex < questions.length) {
                    renderQuestion();
                } else {
                    completeQuiz();
                }
            }, 300);
        }

        async function completeQuiz() {
            const timestamp = new Date().toISOString();
            
            const location = await getLocation();
            
            const data = {
                timestamp,
                ...responses
            };
            
            if (location) {
                data.loc = location;
            }

            await saveToSheet(data);
            showScreen('chartScreen');
        }

        // ============================================
        // DRAG HANDLERS
        // ============================================
        function startDrag(e) {
            const question = questions[currentQuestionIndex];
            if (question.type === 'rating' || question.type === 'text' || question.type === 'hours') return;

            e.preventDefault();
            isDragging = true;
            dragStartX = e.touches ? e.touches[0].clientX : e.clientX;
            dragOffset = 0;

            const card = document.getElementById('card');
            if (card) card.classList.add('dragging');
        }

        function drag(e) {
            if (!isDragging) return;

            const question = questions[currentQuestionIndex];
            const currentX = e.touches ? e.touches[0].clientX : e.clientX;
            dragOffset = currentX - window.innerWidth / 2;

            const card = document.getElementById('card');
            if (!card) return;

            const rotation = dragOffset * 0.1;
            card.style.transform = `translateX(${dragOffset}px) rotate(${rotation}deg)`;

            if (Math.abs(dragOffset) > 50) {
                if (dragOffset > 0) {
                    card.style.backgroundColor = COLOR_MAP[question.color] + '20';
                } else {
                    card.style.backgroundColor = '#1A1A1A';
                }
            } else {
                card.style.backgroundColor = '#0D0D0D';
            }
        }

        function endDrag() {
            if (!isDragging) return;

            const question = questions[currentQuestionIndex];
            const card = document.getElementById('card');
            
            if (Math.abs(dragOffset) > 150) {
                const answer = dragOffset > 0 ? 'yes' : 'no';
                responses[question.id] = answer;

                card.style.transition = 'transform 0.3s ease';
                card.style.transform = `translateX(${dragOffset > 0 ? '1000px' : '-1000px'}) rotate(${dragOffset > 0 ? '30deg' : '-30deg'})`;

                setTimeout(() => {
                    card.style.transition = '';
                    currentQuestionIndex++;
                    if (currentQuestionIndex < questions.length) {
                        renderQuestion();
                    } else {
                        completeQuiz();
                    }
                }, 300);
            } else {
                card.style.transform = 'none';
                card.style.backgroundColor = '#0D0D0D';
            }

            isDragging = false;
            dragOffset = 0;
            if (card) card.classList.remove('dragging');
        }

        // ============================================
        // SPEECH RECOGNITION
        // ============================================
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';

                recognition.onresult = (event) => {
                    const textInput = document.getElementById('textInput');
                    if (!textInput) return;

                    let finalTranscript = '';
                    let interimTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript + ' ';
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    textInput.value = (textInput.value + finalTranscript).trim();
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    stopRecording();
                };
            }
        }

        function toggleRecording() {
            if (!recognition) {
                alert('Speech recognition not supported in this browser');
                return;
            }

            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function startRecording() {
            if (!recognition) return;

            try {
                recognition.start();
                isRecording = true;
                const micBtn = document.getElementById('micBtn');
                if (micBtn) {
                    micBtn.classList.add('recording');
                }
            } catch (error) {
                console.error('Error starting recording:', error);
            }
        }

        function stopRecording() {
            if (!recognition || !isRecording) return;

            try {
                recognition.stop();
                isRecording = false;
                const micBtn = document.getElementById('micBtn');
                if (micBtn) {
                    micBtn.classList.remove('recording');
                }
            } catch (error) {
                console.error('Error stopping recording:', error);
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        window.onload = () => {
            initializeGoogleAuth();
            initPopupDragHandlers();
            initSpeechRecognition();
            
            // Add click handler for chart
            const canvas = document.getElementById('myChart');
            canvas.addEventListener('click', handleChartClick);
            
            // Redraw chart on resize
            window.addEventListener('resize', () => {
                clearTimeout(window.resizeTimer);
                window.resizeTimer = setTimeout(updateChart, 100);
            });
        };
    </script>
</body>
</html>
